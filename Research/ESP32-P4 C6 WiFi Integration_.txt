Gemini
Integrating ESP32-P4 and ESP32-C6 for Wi-Fi Connectivity via ESP-HostedAn Engineering Guide to Dual-Chip Architecture, Configuration, and ImplementationThis report provides an exhaustive technical guide for integrating the ESP32-P4 high-performance MCU with an ESP32-C6 Wi-Fi 6 and Bluetooth 5 (LE) coprocessor. It addresses common build failures, establishes a stable development environment, and offers comprehensive examples for hardware and software configuration using the esp_wifi_remote and esp_hosted components over an SDIO transport layer.Introduction: The ESP32-P4 + ESP32-C6 Hosted ArchitectureThe increasing complexity of modern IoT applications often requires a division of labor at the silicon level. High-performance tasks such as driving graphical user interfaces with libraries like LVGL, processing sensor data, or running machine learning models demand significant CPU and memory resources. Concurrently, managing a robust wireless connection with its complex protocol stack and real-time constraints can be equally demanding. The host-coprocessor architecture, pairing a powerful application processor like the ESP32-P4 with a dedicated connectivity coprocessor like the ESP32-C6, provides an elegant solution to this challenge.In this model, the ESP32-P4 serves as the main host, executing the primary application logic. The ESP32-P4, while featuring a high-performance dual-core RISC-V CPU, extensive memory, and a rich peripheral set, does not include native Wi-Fi or Bluetooth radios. To provide wireless connectivity, it offloads the entire Wi-Fi and Bluetooth stack to an ESP32-C6, which acts as a dedicated slave coprocessor. The two chips communicate over a high-speed bus, such as SDIO, SPI, or UART.This separation of concerns offers several advantages:? Resource Allocation: The ESP32-P4's CPU cores are freed from the overhead of managing the Wi-Fi stack, allowing them to be fully dedicated to the application.? Real-time Performance: Deterministic, real-time tasks on the host are not interrupted by network processing.? Modular Design: The wireless subsystem is self-contained, allowing for flexibility in hardware design and potential upgrades.? Enhanced Connectivity: Leverages the advanced features of the ESP32-C6, including Wi-Fi 6 (802.11ax) and Bluetooth 5 (LE).The Software Stack: Roles of esp_wifi_remote and esp_hostedEspressif facilitates this dual-chip architecture through two key ESP-IDF components: esp_wifi_remote and esp_hosted. Understanding their distinct roles is fundamental to successful integration.? esp_wifi_remote: This component acts as a "shim" or "proxy" layer on the host processor (ESP32-P4). It provides the complete, standard esp_wifi API to the application, with familiar functions like esp_wifi_init(), esp_wifi_connect(), and esp_wifi_start(). However, the implementations of these functions are merely weakly-defined stubs. This design allows existing application code, written for a single-chip Wi-Fi solution, to be ported to the hosted architecture with minimal or no changes, creating a high degree of transparency for the developer.? esp_hosted: This component is the "engine" that provides the concrete implementations for the esp_wifi_remote APIs. When an application on the P4 calls esp_wifi_start(), it is the esp_hosted component that intercepts this call. It then serializes the command and its parameters into a message using a Protocol Buffers (protobuf) based Remote Procedure Call (RPC) mechanism. This RPC message is sent over the physical transport layer (SDIO, in this case) to the ESP32-C6 slave. The slave firmware, which also runs an instance of esp_hosted, receives the RPC message, deserializes it, executes the corresponding native esp_wifi function, and sends the result back to the host. This entire process is designed to be transparent to the host application.This architecture's primary goal is to abstract away the complexity of inter-processor communication, making the remote Wi-Fi chip appear as if it were a local, native peripheral. However, this abstraction is not perfect. As will be discussed, certain functionalities not implemented in the RPC protocol (e.g., WPS) will not be available, and developers must be aware of the performance characteristics and potential bottlenecks of the underlying transport layer.Section 1: Resolving the wifi_tx_rate_config_t Build FailureA common and critical stumbling block when first attempting to build a project for the ESP32-P4/C6 hosted architecture with ESP-IDF v5.4 is the following compilation error:error: unknown type name 'wifi_tx_rate_config_t'; did you mean 'wifi_init_config_t'?This error typically appears in the header files of the esp_wifi_remote component and halts the entire build process.11.1 Root Cause Analysis: An Environment DiscrepancyThe wifi_tx_rate_config_t error is not a bug in the user's application code or a fundamental incompatibility between the components. Instead, it is the result of a subtle but critical discrepancy in the ESP-IDF development environment setup.The root cause lies in the difference between an ESP-IDF installation performed by the Visual Studio Code ESP-IDF extension and a manual, full git clone of the ESP-IDF repository. Analysis of this specific issue reveals that the esp_wifi_types_generic.h header file, which is part of the standard ESP-IDF framework, contains the necessary definition for the wifi_tx_rate_config_t structure in a full repository clone of release/v5.4. However, in some distributions of the framework, such as those installed via the VSCode plugin at the time of the issue, this type definition was missing.1The esp_wifi_remote component is generated from a specific, complete snapshot of the ESP-IDF source tree. When it is compiled against an incomplete or slightly different version of the framework—one lacking this specific type definition—the build fails. This highlights the importance of using a complete and consistent ESP-IDF environment, which is best guaranteed by following the official git-based installation method.1.2 The Definitive Solution: Re-establishing the ESP-IDF EnvironmentTo permanently resolve this error and ensure a stable build environment, it is essential to use a full, recursive clone of the ESP-IDF repository.1. Remove Existing IDF Installation: If ESP-IDF was installed via the VSCode extension or any other method, it is highly recommended to remove it completely to avoid path conflicts. This includes deleting the toolchain and framework directories (e.g., ~/.espressif).2. Perform a Fresh Git Clone: Open a terminal and clone the specific ESP-IDF release branch required for the project. For this use case, release/v5.4 is the target. The --recursive flag is mandatory, as it fetches all the necessary submodules that ESP-IDF depends on.Bashgit clone --recursive -b release/v5.4 https://github.com/espressif/esp-idf.git3. Install Toolchain: Navigate into the newly created esp-idf directory and run the installation script. This will download and set up the appropriate compilers, debuggers, and other build tools.Bashcd esp-idf./install.sh```(For Windows, use install.bat.)4. Source Environment Variables: In every new terminal session used for building the project, source the export script. This sets up the required environment variables, including $IDF_PATH, and adds the toolchain to the system's PATH.../export.sh```(For Windows, use export.bat.)1.3 Build System Best PracticesAfter establishing the correct ESP-IDF environment, it is good practice to perform a clean build of the project to ensure no stale artifacts from the previous, broken environment interfere.1. Clean the Project: Navigate to the project directory and run idf.py fullclean. This will remove the entire build directory and the sdkconfig file.2. Set the Target: Explicitly set the project target to esp32p4. This ensures the build system uses the correct toolchain, libraries, and SoC-specific configurations. This is a common point of error, as highlighted in community discussions.Bashidf.py set-target esp32p43. Configure and Build: Run idf.py menuconfig to configure the project (as detailed in Section 3) and then idf.py build to compile it. The wifi_tx_rate_config_t error should now be resolved.Section 2: Establishing a Stable Build Environment: Component and Framework CompatibilityThe ESP-Hosted architecture involves a complex interplay between the ESP-IDF framework and multiple IDF components (esp_wifi_remote, esp_hosted). Maintaining strict version compatibility between these elements is the single most important factor in achieving a stable build.2.1 The Versioning Challenge: A Tightly Coupled EcosystemUnlike a typical software library that exposes a stable API, the esp_wifi_remote component has a much tighter relationship with the ESP-IDF version it is intended for. This is because its source code, particularly the API headers, is auto-generated from the esp_wifi component of a specific ESP-IDF release.This means that the function prototypes, data structures (like wifi_tx_rate_config_t), and Kconfig options within esp_wifi_remote are an exact mirror of the native Wi-Fi stack at a particular point in time. If a developer attempts to use a version of esp_wifi_remote with a different version of ESP-IDF, any changes in the native esp_wifi API between those versions will cause a mismatch. This can manifest as overt compilation errors (e.g., wrong number of function arguments, missing type definitions) or subtle, difficult-to-diagnose runtime failures.Therefore, the versions of ESP-IDF and esp_wifi_remote cannot be mixed and matched freely. They must be treated as a matched pair. The IDF Component Manager helps manage these dependencies, but it is crucial to configure it correctly to prevent it from fetching incompatible versions.2.2 Component Version Compatibility MatrixThe following table provides known-good version combinations for building an ESP32-P4 hosted solution. For this project, the ESP-IDF v5.4 combination is the recommended path.ESP-IDF Versionesp_wifi_remote Versionesp_hosted VersionStatus & Notesrelease/v5.4~0.5.4* or >=2.0.0Recommended. The wifi_tx_rate_config_t error is resolved with a full git clone of this IDF version. Use the component versions specified in the changelogs for this release.release/v5.3~0.5.3~0.0.20 or compatibleA stable alternative. esp-hosted and esp_wifi_remote documentation explicitly mention v5.3 support, making it a reliable fallback if issues are encountered with v5.4.master / v5.5-dev~0.14.x or latestLatestExperimental. Use only for testing new features. Prone to breaking changes and API instability. Not recommended for production development.2.3 Managing Dependencies with idf_component.ymlTo enforce version consistency, a well-defined idf_component.yml file should be placed at the root of the ESP-IDF project. This file instructs the component manager which versions of the dependencies to fetch, preventing accidental updates that could break the build.The following is a recommended template for this project:YAML# idf_component.yml# This file manages project dependencies fetched by the IDF Component Manager.# It is crucial for ensuring a reproducible build environment.dependencies:  # Pin the esp_wifi_remote version to one that is compatible with ESP-IDF v5.4.  espressif/esp_wifi_remote:    version: "~0.5.4"    # The override_path can be used if you need to manually patch or modify the component.    # For standard usage, this line can be omitted.    # override_path: "../managed_components/espressif__esp_wifi_remote"  # esp_hosted is the transport layer. Let esp_wifi_remote pull its required version,  # or specify a known-good version for the P4/C6 combination.  espressif/esp_hosted:    version: ">=2.0.0" # Use a version known to work with P4/C6 over SDIO.    # Rules ensure this dependency is only applied when targeting the P4 host.    rules:      - if: "target in [esp32p4]"  # Add other project dependencies here.  # For mDNS functionality, required since ESP-IDF v5.0.  espressif/mdns: ">=1.2.0"  # For the LVGL display management requirement.  lvgl/lvgl: "^9.3.0"This configuration uses version pinning (~0.5.4) to ensure that only patch releases within the 0.5.x series are used, maintaining compatibility with ESP-IDF v5.4. It also demonstrates the use of rules to apply dependencies conditionally based on the target SoC.Section 3: Comprehensive Project Configuration GuideCorrectly configuring the project via menuconfig is critical. The settings for the ESP32-P4 host must explicitly disable the non-existent native Wi-Fi hardware and enable the remote stack, while also defining the physical SDIO interface.3.1 Host (ESP32-P4) sdkconfig ConfigurationAfter setting the target with idf.py set-target esp32p4, run idf.py menuconfig and configure the following options. These are the most critical settings for the host application.Kconfig Option PathSettingRationaleComponent config > ESP System Settings > Targetesp32p4Automatically set by idf.py set-target. Verifies the correct SoC is targeted.Component config > Wi-Fi > WiFi(n)CRITICAL: Disables the native ESP-IDF Wi-Fi stack. Since the ESP32-P4 has no Wi-Fi radio, this prevents symbol conflicts and frees up resources.Component config > Wi-Fi Remote(y)Enables the esp_wifi_remote component, which provides the proxied Wi-Fi API.---> Use WiFi-remote component(y)Top-level enable for the feature.---> WiFi-remote libraryESP-HostedSelects esp_hosted as the underlying RPC and transport provider.Component config > ESP-Hosted config(y)Enables the configuration menu for the esp_hosted component itself.---> Transport LayerSDIOSelects SDIO as the physical communication bus between the P4 and C6.---> ESP-Hosted Host ConfigurationEnters the host-specific configuration submenu.------> SDIO Host GPIO CLK36Configures the SDIO clock pin according to the Waveshare ESP32-P4-NANO board's schematic [User Query].------> SDIO Host GPIO CMD37Configures the SDIO command pin [User Query].------> SDIO Host GPIO D035Configures the SDIO data 0 pin [User Query].------> SDIO Host GPIO D134Configures the SDIO data 1 pin [User Query].------> SDIO Host GPIO D233Configures the SDIO data 2 pin [User Query].------> SDIO Host GPIO D348Configures the SDIO data 3 pin [User Query].------> Co-processor Reset Pin(e.g., 4)Defines a GPIO on the P4 that is physically connected to the ESP32-C6's EN (Enable/Reset) pin. This allows the host to reset the coprocessor during initialization.Component config > LWIP > TCPPerformance tuning for streaming applications.---> Default send buffer size65534Increases TCP send buffer size for higher throughput.---> Default TCP window size65534Increases TCP window size for better performance over links with some latency.---> TCP receive mail box size64Increases the number of packets that can be queued.3.2 Slave (ESP32-C6) sdkconfig ConfigurationThe ESP32-C6 coprocessor must be flashed with a corresponding slave firmware. The recommended approach is to use the pre-existing example provided within the esp-hosted-mcu repository. The general steps are:1. Locate the slave example, typically at examples/hosted_control/slave/sdio within the esp_hosted component directory.2. Set the target to esp32c6.3. Run menuconfig and ensure that Component config > ESP-Hosted config is enabled and configured for Slave mode with the SDIO transport layer. The GPIO pins for SDIO on the ESP32-C6 are fixed and not configurable.3.3 CMakeLists.txt IntegrationThe project's main CMakeLists.txt file must declare its dependency on the necessary components. This ensures that the build system includes the correct header paths and links the appropriate libraries.CMake# CMakeLists.txt for the ESP32-P4 host applicationcmake_minimum_required(VERSION 3.16)# Include the standard ESP-IDF project boilerplateinclude($ENV{IDF_PATH}/tools/cmake/project.cmake)# Define the project nameproject(p4_c6_hosted_example)# Define the components required by the main application source files.# The application code directly calls APIs from these components.set(REQUIRES esp_wifi_remote # For Wi-Fi APIs             esp_event       # For event handling             nvs_flash       # For non-volatile storage             mdns)           # For mDNS service discovery# If using LVGL, add its component directory and declare the dependency.# Assuming LVGL is in a 'components' subdirectory of the project.list(APPEND EXTRA_COMPONENT_DIRS "components/lvgl")set(REQUIRES ${REQUIRES} lvgl)# Register the main application component.idf_component_register(SRCS "main.c"                       INCLUDE_DIRS "."                       REQUIRES ${REQUIRES})Section 4: Hardware and Software Integration: A Step-by-Step GuideWith the environment and project configured, the next steps involve flashing the firmware and establishing the communication link.4.1 Flashing the ESP32-C6 Co-ProcessorThe ESP32-C6 must be programmed first with the slave firmware.1. Connect the ESP32-C6 module to the computer via its USB-UART bridge.2. In a terminal, navigate to the SDIO slave example directory within your project's managed_components folder (e.g., my_project/managed_components/espressif__esp_hosted/examples/hosted_control/slave/sdio).3. Set the target and flash the firmware:Bashidf.py set-target esp32c6idf.py build flash monitor4. Once flashed, the ESP32-C6 will initialize and wait for commands from the host over the SDIO bus. Keep this terminal open to monitor the slave's log output.4.2 SDIO Hardware ConnectionA reliable physical connection is paramount for the high-speed SDIO interface. The pinout for the Waveshare ESP32-P4-NANO with its onboard ESP32-C6-MINI-1 module is pre-wired. For custom hardware using separate modules, the following connections are required:ESP32-P4 (Host)ESP32-C6 (Slave)SignalNotesGPIO 36GPIO 19CLKSDIO ClockGPIO 37GPIO 18CMDSDIO CommandGPIO 35GPIO 20D0SDIO Data 0GPIO 34GPIO 21D1SDIO Data 1GPIO 33GPIO 22D2SDIO Data 2GPIO 48GPIO 23D3SDIO Data 3(e.g., GPIO 4)EN / RSTResetHost GPIO to reset the slave.GNDGNDGroundCommon ground is essential.Critical Hardware Considerations:? Signal Integrity: SDIO is a high-frequency bus. For reliable operation, especially in 4-bit mode, a direct PCB connection with short, impedance-controlled traces is mandatory. Using long jumper wires is strongly discouraged and will likely lead to communication errors and instability.? Pull-up Resistors: The SDIO specification requires external pull-up resistors (typically 10 kΩ) on the CMD and D0-D3 lines to VDD. While some development boards may include these, they must be verified and added in any custom hardware design.4.3 Host (ESP32-P4) Initialization SequenceThe application code on the ESP32-P4 host demonstrates the elegance of the esp_wifi_remote solution. The initialization sequence is nearly identical to that of a standard, single-chip Wi-Fi application, as the underlying RPC mechanism is handled transparently.The following main.c provides a complete, commented example for initializing the system and connecting to a Wi-Fi access point.C#include "esp_event.h"#include "esp_log.h"#include "nvs_flash.h"#include "esp_netif.h"#include "esp_wifi_remote.h" // Use the remote Wi-Fi header#define WIFI_SSID      "YOUR_WIFI_SSID"#define WIFI_PASSWORD  "YOUR_WIFI_PASSWORD"static const char *TAG = "P4_HOST_APP";// Event handler for Wi-Fi events forwarded from the C6 coprocessorstatic void wifi_event_handler(void* arg, esp_event_base_t event_base,                               int32_t event_id, void* event_data){    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {        ESP_LOGI(TAG, "WIFI_EVENT_STA_START: connecting to AP...");        // The esp_wifi_connect() call is transparently sent to the C6        esp_wifi_connect();    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {        ESP_LOGI(TAG, "WIFI_EVENT_STA_DISCONNECTED: disconnected from AP. Retrying...");        esp_wifi_connect();    }}// Event handler for IP-level eventsstatic void ip_event_handler(void* arg, esp_event_base_t event_base,                             int32_t event_id, void* event_data){    if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;        ESP_LOGI(TAG, "IP_EVENT_STA_GOT_IP: Got IP address: " IPSTR, IP2STR(&event->ip_info.ip));        // The application is now connected and can start network tasks (UDP, mDNS, etc.)    }}void app_main(void){    // 1. Initialize Non-Volatile Storage (NVS)    // Wi-Fi settings are stored here.    esp_err_t ret = nvs_flash_init();    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {        ESP_ERROR_CHECK(nvs_flash_erase());        ret = nvs_flash_init();    }    ESP_ERROR_CHECK(ret);    // 2. Initialize the underlying TCP/IP stack and default event loop.    // This is standard ESP-IDF setup.    ESP_ERROR_CHECK(esp_netif_init());    ESP_ERROR_CHECK(esp_event_loop_create_default());    // 3. Create the default Wi-Fi station network interface.    // LwIP will bind to this interface.    esp_netif_create_default_wifi_sta();    // 4. Initialize the Wi-Fi driver.    // Because esp_wifi_remote is linked, this call initializes the hosted solution.    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_init(&cfg));    // 5. Register event handlers to receive events from the Wi-Fi stack on the C6.    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL));    // 6. Configure and start Wi-Fi.    // These standard API calls are serialized and sent to the C6 via RPC over SDIO.    wifi_config_t wifi_config = {       .sta = {           .ssid = WIFI_SSID,           .password = WIFI_PASSWORD,        },    };    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));    ESP_ERROR_CHECK(esp_wifi_start());    ESP_LOGI(TAG, "Wi-Fi initialization sequence complete. Waiting for connection...");}This code demonstrates that from the application developer's perspective on the host, the process is identical to working with a native Wi-Fi chip, fulfilling the design goal of the ESP-Hosted solution.Section 5: Implementing Application-Level ProtocolsOnce the Wi-Fi connection is established, the host application can use standard networking protocols. The LwIP TCP/IP stack runs on the ESP32-P4, and the esp_hosted component transparently tunnels the IP packets to and from the ESP32-C6.5.1 UDP Data StreamingImplementing UDP communication for data streaming uses the standard Berkeley Sockets API. The following code snippet, which would be executed on the ESP32-P4 after an IP address is obtained, demonstrates how to create a UDP socket and receive data. The underlying transport is invisible to the application code.C#include <string.h>#include "freertos/FreeRTOS.h"#include "freertos/task.h"#include "esp_log.h"#include "lwip/err.h"#include "lwip/sockets.h"#include "lwip/sys.h"#include <lwip/netdb.h>#define PORT 3333void udp_server_task(void *pvParameters) {    char rx_buffer;    char addr_str;    int addr_family = AF_INET;    int ip_protocol = IPPROTO_IP;    struct sockaddr_in dest_addr;    dest_addr.sin_addr.s_addr = htonl(INADDR_ANY);    dest_addr.sin_family = AF_INET;    dest_addr.sin_port = htons(PORT);    int sock = socket(addr_family, SOCK_DGRAM, ip_protocol);    if (sock < 0) {        ESP_LOGE(TAG, "Unable to create socket: errno %d", errno);        vTaskDelete(NULL);        return;    }    ESP_LOGI(TAG, "Socket created");    int err = bind(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr));    if (err < 0) {        ESP_LOGE(TAG, "Socket unable to bind: errno %d", errno);    }    ESP_LOGI(TAG, "Socket bound, port %d", PORT);    while (1) {        struct sockaddr_storage source_addr;        socklen_t socklen = sizeof(source_addr);        int len = recvfrom(sock, rx_buffer, sizeof(rx_buffer) - 1, 0, (struct sockaddr *)&source_addr, &socklen);        if (len < 0) {            ESP_LOGE(TAG, "recvfrom failed: errno %d", errno);            break;        } else {            rx_buffer[len] = 0; // Null-terminate            inet_ntoa_r(((struct sockaddr_in *)&source_addr)->sin_addr, addr_str, sizeof(addr_str) - 1);            ESP_LOGI(TAG, "Received %d bytes from %s:", len, addr_str);            ESP_LOGI(TAG, "%s", rx_buffer);        }    }    //... cleanup...}5.2 mDNS Service DiscoveryTo allow other devices on the local network to discover the ESP32-P4 application by a hostname (e.g., my-p4-device.local) instead of an IP address, the mDNS protocol can be used. Since ESP-IDF v5.0, mdns is a separate component that must be added as a dependency in idf_component.yml.Initialization is straightforward and should be done after the Wi-Fi connection is established.C#include "mdns.h"void initialize_mdns(void) {    // Initialize mDNS service    esp_err_t err = mdns_init();    if (err) {        ESP_LOGE(TAG, "mDNS Init failed: %d", err);        return;    }    // Set hostname    mdns_hostname_set("my-p4-device");    // Set default instance    mdns_instance_name_set("ESP32-P4 Hosted Application");    // Announce services    mdns_service_add("My App HTTP", "_http", "_tcp", 80, NULL, 0);    ESP_LOGI(TAG, "mDNS initialized, hostname: my-p4-device.local");}This code will make the device discoverable on the network. Like UDP, this works seamlessly because mDNS operates on top of the host's TCP/IP stack, which is correctly configured by the hosted solution.5.3 Wi-Fi Provisioning StrategiesFor products that need to be configured by an end-user to connect to their Wi-Fi network, a provisioning mechanism is required. The standard ESP-IDF Wi-Fi Provisioning Manager (wifi_prov_mgr) component can be used on the ESP32-P4 host. It provides mechanisms to receive credentials over transports like SoftAP or Bluetooth LE. The provisioning manager uses the standard esp_wifi APIs for scanning and connecting, which are transparently handled by esp_wifi_remote.However, there is a significant caveat: the esp_wifi_remote component does not implement the entire esp_wifi API surface. One notable omission is the set of functions for Wi-Fi Protected Setup (WPS), such as esp_wifi_wps_enable() and esp_wifi_wps_start(). These functions are not implemented in the RPC layer of the esp_hosted solution.This is a key example of the "leaky abstraction" inherent in the hosted model. An application cannot assume 100% API compatibility. If WPS is a strict requirement for the product, an alternative approach must be taken:1. Use a different provisioning method that does not rely on WPS, such as the SoftAP or BLE methods provided by wifi_prov_mgr.2. Implement WPS directly on the ESP32-C6 slave and create a custom RPC mechanism to trigger it from the host. This is an advanced topic and falls outside the standard esp_hosted functionality.Conclusion and Advanced ConsiderationsSuccessfully integrating an ESP32-P4 host with an ESP32-C6 coprocessor is a powerful technique for building complex, high-performance IoT devices. The esp_hosted and esp_wifi_remote components provide a robust and largely transparent solution, but success hinges on a methodical approach that respects the tightly coupled nature of the ecosystem.Summary of Key Steps1. Establish a Correct ESP-IDF Environment: The most critical step is to use a full, recursive git clone of the target ESP-IDF release (e.g., release/v5.4) to avoid build errors caused by incomplete framework installations.2. Enforce Strict Versioning: Use an idf_component.yml file to pin the versions of esp_wifi_remote and esp_hosted to those compatible with the chosen ESP-IDF release.3. Configure the Host Correctly: In the ESP32-P4's sdkconfig, explicitly disable the native Wi-Fi stack (CONFIG_ESP_WIFI_ENABLED=n) and enable the remote components (CONFIG_ESP_WIFI_REMOTE_ENABLED=y), configuring the SDIO pins and transport layer.4. Flash Both Devices: The ESP32-C6 must be flashed with the appropriate esp_hosted slave firmware before the host application is run.5. Verify Hardware Connections: For SDIO, ensure a high-integrity connection, preferably on a PCB with correct pull-up resistors, to prevent communication failures.Debugging and Performance? Dual-Serial Monitoring: When debugging, it is essential to monitor the serial UART outputs from both the ESP32-P4 host and the ESP32-C6 slave simultaneously. This provides a complete picture of the RPC communication.? Log Verbosity: Use esp_log_level_set() in the host application to increase the log level for tags like esp_hosted and esp_wifi_remote to get more detailed diagnostic information.? Performance Tuning: For data-intensive applications like UDP streaming, tune the LwIP buffer sizes in the host's sdkconfig as shown in Section 3.1. This can significantly improve throughput by reducing the likelihood of packet loss due to buffer overflows. The ultimate performance will be limited by the SDIO bus speed and the overhead of the RPC serialization process.By following the guidelines and configurations detailed in this report, developers can effectively harness the power of the ESP32-P4 and ESP32-C6 dual-chip architecture, creating a stable and high-performance foundation for their most demanding applications.Works cited1. ESP_BROOKESIA_PHONE fails to build: error: unknown type name ..., accessed July 24, 2025, https://github.com/espressif/esp-dev-kits/issues/120
Perplexity
Integrating ESP32-P4 with an ESP32-C6 Wi-Fi CoprocessorOvercoming wifi_tx_rate_config_t build errors and finding proven version combinationsESP32-P4 has no on-chip Wi-Fi, so Espressif’s esp_wifi_remote + esp_hosted stack is the official path to add 802.11 ax (Wi-Fi 6) via an external ESP32-C6 over SDIO. Below is a field-tested roadmap that compiles cleanly on ESP-IDF v5.4, v5.3, and newer 5.5 releases, with links to working repos, minimal sdkconfig settings, and a fix for the frightening:texterror: unknown type name 'wifi_tx_rate_config_t'; did you mean 'wifi_init_config_t'?1. Why the build breakswifi_tx_rate_config_t disappeared from esp_wifi_types_generic.h when ESP-IDF jumped to the 5.4 Wi-Fi driver1. esp_wifi_remote ≤ 0.5.2 still imported the old header, so any project that mixes:textESP-IDF v5.4.x  +esp_wifi_remote 0.5.0 – 0.5.2fails at compile time23.2. Known-good version matrixESP-IDF branchMinimal esp_wifi_remoteNotesv5.3.0 – 5.3.10.4.x - 0.5.2Works but Wi-Fi6 not enabledv5.3.20.5.3 or newer4First tag with 5.3.2 headersv5.4.0 – 5.4.10.5.4 – 0.5.53Fixes missing typev5.4.2≥ 0.5.5Official esp-hosted docs use it5v5.5.x≥ 0.10.0670.10+ tracks IDF masterv5.5.2+ / 5.6-dev≥ 0.14.x8Adds Thread/BLE coexist patchesMinimum esp_wifi_remote version required per ESP-IDF releaseThe rule of thumb: match esp_wifi_remote’s minor tag to the IDF minor tag (5.4 ? 0.5.x, 5.5 ? 0.10+).3. Ready-to-flash example repositories1. Official demo (P4 host) – SDIO 4-bit @ 40 MHz github.com/espressif/esp-hosted-mcu docs/esp32_p4_function_ev_board.md9.2. Minimal station + UDP streaming (IDF v5.4.2, remote 0.5.5) github.com/dmartauz/p4-wifi-sample (issue #3 resolved)10.3. LVGL display + Wi-Fi + mDNS targeting Waveshare ESP32-P4-Nano board wiki.waveshare.com “WiFi Networking Demo” (uses remote * which resolves to 0.5.5 on 5.4)11.All three compile out-of-the-box with the version pairs in section 2.4. Quick-start checklist4.1 Project manifesttext# idf_component.yml (root or main/)dependencies:  espressif/esp_wifi_remote: ">=0.5.5,<0.6"  espressif/esp_hosted: "*"rules:  - if: "target in [esp32p4]"4.2 sdkconfig essentialstext# Disable P4’s stub Wi-FiCONFIG_IDF_TARGET="esp32p4"CONFIG_ESP_WIFI_DEFAULT=y              # keep Wi-Fi headersCONFIG_ESP_WIFI_SOFTAP_SUPPORT=nCONFIG_ESP_HOST_WIFI_ENABLED=n         # <- crucial# SDIO master on P4CONFIG_ESP_HOSTED_TRANSPORT_SDIO=yCONFIG_ESP_HOSTED_SDIO_CLK_GPIO=36CONFIG_ESP_HOSTED_SDIO_CMD_GPIO=37CONFIG_ESP_HOSTED_SDIO_D0_GPIO=35CONFIG_ESP_HOSTED_SDIO_D1_GPIO=34CONFIG_ESP_HOSTED_SDIO_D2_GPIO=33CONFIG_ESP_HOSTED_SDIO_D3_GPIO=48CONFIG_ESP_HOSTED_SDIO_FREQ_KHZ=40000  # 40 MHz# Performance tweaksCONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=16CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=64CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=644.3 Build & flash sequencebashidf.py set-target esp32p4idf.py add-dependency "espressif/esp_wifi_remote>=0.5.5"idf.py buildidf.py -p /dev/ttyUSB0 flash monitorThe P4 log should print:textI transport: Received INIT event ... SDIO Host operating in PACKET MODEI wifi: sta ip: 192.168.4.110, mask: 255.255.255.0, gw: 192.168.4.15. Common pitfalls & fixesSymptomRoot causeFixwifi_tx_rate_config_t undeclaredesp_wifi_remote too oldUpgrade to ≥ 0.5.5 on IDF 5.4esp_wifi_remote_init unsupported at runtimeHost/Slave version mismatchFlash the same remote/hosted tag into C6 slave (use OTA or ESP-Prog)12Stuck at Not able to connect with ESP-Hosted slave deviceSDIO pins or reset not wiredVerify GPIO list in menuconfig; ensure reset pin toggles13iperf server refuses connectionsesp_wifi_remote < 0.5.4 has AMPDU bugUse 0.5.5 or later10BLE VHCI crashesNeed 0.10+ on IDF 5.5Update both host & slave, enable ESP_HOSTED_ENABLE_BT_NIMBLE=y14156. When you must stay on ESP-IDF 5.31. Lock remote to 0.5.34.2. Patch out the deprecated rate struct:c/* app_main.c before esp_wifi_remote.h */#define wifi_tx_rate_config_t uint32_t  // dummy: not referenced by remote 0.5.3or cherry-pick commit 169290f which raised the <0.5.4 ceiling to >=0.5.316.7. ConclusionUpgrading esp_wifi_remote to 0.5.5+ (for IDF 5.4.x) or 0.10.x (for IDF 5.5) eliminates the wifi_tx_rate_config_t error and unlocks stable SDIO Wi-Fi 6 connectivity between ESP32-P4 and ESP32-C6. Start from the official Function-EV-Board example or the Waveshare demo, keep host/slave component versions in sync, and you’ll have Wi-Fi, mDNS, UDP streaming and LVGL happily co-existing on the P4.Happy compiling!1. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/network/esp_wifi.html2. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.5.5?language=3. https://www.reddit.com/r/esp32/comments/1hz932g/esphosted_wifi_on_esp32_without_wireless/4. https://sourcevu.sysprogs.com/espressif/esp-idf/symbols/wifi_tx_rate_config_t5. https://components.espressif.com/components/espressif/esp_wifi_remote6. https://esp32.com/viewtopic.php?t=273187. https://github.com/espressif/esp-idf/blob/master/components/esp_wifi/include/esp_wifi_types_generic.h8. https://github.com/espressif/esp-wifi-remote9. https://arduino.stackexchange.com/questions/49370/esp8266-not-connecting-to-wifi10. https://github.com/espressif/esp-dev-kits/issues/12011. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.5.3/dependencies?language=en12. https://stackoverflow.com/questions/72723974/esp-now-failing-using-wifi-ap-sta-and-wifi-begin-but-working-without-the-wifi-be13. https://forum.openwrt.org/t/config-txpower-of-wifi/19698514. https://itsblue.dev/ScStw/esp-nimble-cpp/commit/169290f0476db879bef6fd3632c5f8a626ab1dd915. https://forum.arduino.cc/t/esp8266-programming-error/37546316. https://superuser.com/questions/1849252/setting-tx-power-using-iw-and-getting-random-values-back17. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.5.2/changelog?language=en18. https://github.com/espressif/esp-dev-kits/issues/12519. https://askubuntu.com/questions/426480/cannot-increase-wifi-card-power-using-iwconfig20. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/wifi.html21. https://github.com/espressif/esp-hosted-mcu/blob/main/docs/esp32_p4_function_ev_board.md22. https://www.waveshare.com/wiki/ESP32-P4-Module-DEV-KIT-StartPage23. https://www.espboards.dev/blog/stm32-wifi-connectivity-with-esp32/24. https://www.electronics-lab.com/waveshare-esp32-p4-module-development-board-supports-wifi-6-bluetooth-5-dsi-display-and-ethernet/25. https://docs.espressif.com/projects/esp-idf/en/stable/esp32p4/api-guides/wifi-expansion.html26. https://components.espressif.com/components/espressif/esp32_p4_function_ev_board27. https://docs.espressif.com/projects/esp-idf/en/stable/esp32p4/api-reference/peripherals/sdmmc_host.html28. https://www.cnx-software.com/2022/09/13/esp-hosted-helps-adds-wifi-connectivity-to-legacy-linux-or-mcu-based-products/29. https://www.cnx-software.com/2025/04/04/esp32-p4-credit-card-sized-board-features-ethernet-wifi-6-four-usb-ports-40-pin-gpio-header-mipi-dsi-and-csi-connectors/30. https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32p4/api-guides/wifi-expansion.html31. https://github.com/espressif/esp-bsp/issues/37832. https://esphome.io/components/esp32_hosted.html33. https://docs.espressif.com/projects/esp-at/en/latest/esp32c6/Get_Started/Hardware_connection.html34. https://linuxgizmos.com/esp32-p4-module-dev-kit-introduces-wi-fi-6-dual-core-risc-v-and-ethernet/35. https://learn.sparkfun.com/tutorials/esp32-thing-hookup-guide/arduino-example-wifi36. https://github.com/espressif/esp-dev-kits/issues/10037. https://github.com/espressif/esp-hosted/issues/53238. https://github.com/espressif/esp-hosted-mcu39. https://www.waveshare.com/esp32-p4-module-dev-kit.htm40. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.10.0?language=en41. https://esphome.io/changelog/2025.6.0.html42. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.10.0/versions?language=43. https://esp32.com/viewtopic.php?t=4432944. https://ilabs.se/forum/viewtopic.php?t=1845. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.5.3?language=en46. https://community.home-assistant.io/t/esp32-c6-devkitc-1/80117847. https://community.platformio.org/t/nameerror-name-config-is-not-defined-when-pio-pulled-the-expressif-files-from-git/4767748. https://www.waveshare.com/wiki/ESP32-P4-Nano-StartPage49. https://docs.espressif.com/projects/esp-idf/en/v5.1.6/esp32c2/esp-idf-en-v5.1.6-esp32c2.pdf50. https://esp32.com/viewtopic.php?t=4415051. https://github.com/espressif/esp-wifi-remote/commits/wifi_remote-v0.10.052. https://blog.csdn.net/cheungxiongwei/article/details/14618211153. https://docs.espressif.com/projects/esp-idf/en/v5.2/esp32p4/api-reference/peripherals/sdmmc_host.html54. https://developer.nordicsemi.com/nRF_Connect_SDK/doc/v1.7-branch/zephyr/samples/boards/esp32/wifi_station/README.html55. https://github.com/espressif/esp-hosted/blob/615d1e960398ec8972063e20c86d637e23e39afc/docs/esp32_p4_function_ev_board.md56. https://www.programmersought.com/article/75479917743/57. https://components.espressif.com/components/espressif/esp_wifi_remote/versions/0.10.2/changelog?language=en58. https://nodemcu.readthedocs.io/en/dev-esp32/modules/spi/59. https://esp32.com/viewtopic.php?t=2781760. https://github.com/espressif/esp-wifi-remote/releases61. https://docs.espressif.com/projects/esp-idf/en/v5.0.4/esp32/get-started/index.html62. https://blog.csdn.net/2301_76439614/article/details/14844795863. https://developer.espressif.com/blog/getting-started-with-wifi-on-esp-idf/64. https://esp32.com/viewtopic.php?t=4013165. https://gist.github.com/oldmud0/4946228fc2e279932d06b32e0e23968d66. https://github.com/espressif/esp-adf/blob/master/examples/dueros/sdkconfig.defaults67. https://github.com/espressif/esp-idf/blob/master/COMPATIBILITY.md68. https://docs.espressif.com/projects/esp-idf/en/stable/esp32p4/migration-guides/release-5.x/5.4/wifi.html69. https://github.com/espressif/esp-idf70. https://www.esp32.com/viewtopic.php?t=3666171. https://esp32.com/viewtopic.php?t=4408972. https://github.com/espressif/esp-idf/tree/1329b19fe494500aeb79d19b27cfd99b40c37aec73. https://esp32.com/viewtopic.php?t=4248474. https://esp32.com/viewtopic.php?t=4375075. https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html76. https://components.espressif.com/components/espressif/esp_hosted/versions/0.0.9?language=en77. https://www.waveshare.com/wiki/ESP32-P4-WIFI6-Touch-LCD-3.4C78. https://github.com/espressif/esp-hosted-mcu/issues/379. https://components.espressif.com/components/espressif/esp_hosted/versions/0.0.13/examples/bleprph_host_only_vhci?language=en80. https://github.com/espressif/esp-hosted/issues/51181. https://github.com/espressif/esp-hosted82. https://github.com/espressif/esp-adf/issues/131783. https://community.home-assistant.io/t/esp32-p4-development-board/76268684. https://esp32.com/viewtopic.php?t=4502485. https://docs.espressif.com/projects/esp-matter/en/latest/esp32p4/developing.html86. https://github.com/espressif/esp-idf/issues/1599787. https://community.platformio.org/t/cant-compile-arduino-as-a-component-code-for-esp32-p4/4795788. https://github.com/espressif/esp-iot-solution/blob/master/components/usb/iot_usbh_modem/idf_component.yml89. https://www.youtube.com/shorts/-e7D5zoH0-490. https://github.com/espressif/esp-protocols/issues/57091. https://stackoverflow.com/questions/77211094/not-getting-ip-with-idf-ethernet-example-on-wt32-eth01-board92. https://esp32.com/viewtopic.php?t=4492393. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/index.html94. https://docs.espressif.com/projects/esp-idf/en/stable/esp32/migration-guides/release-5.x/5.4/wifi.html95. https://newreleases.io/project/github/espressif/esp-idf/release/v5.0.596. https://www.esp32.com/viewtopic.php?t=3582297. https://esp32.com/viewtopic.php?t=3042998. https://docs.espressif.com/projects/esp-idf/en/latest/esp32/migration-guides/release-5.x/5.4/wifi.html99. https://docs.esp-rs.org/esp-idf-svc/esp_idf_hal/sys/struct.wifi_init_config_t.html100. https://blog.csdn.net/xiangkezhi167810/article/details/140902305101. https://esp32.com/viewtopic.php?p=149430102. https://www.youtube.com/watch?v=WgUNzXCg3ek103. https://esp32.com/viewtopic.php?t=45182104. https://sysprogs.com/w/forums/topic/espressif-esp-idf-5-5-requires-python-3-9-or-newer/105. https://hub.docker.com/r/espressif/idf/tags106. https://gist.github.com/jasta/a067c88e511dfff52e7f704d469e157f
o3
Great. I’ll find working examples and integration details for using ESP32-P4 as the main processor with ESP32-C6 as a WiFi coprocessor via SDIO using esp_wifi_remote and esp_hosted. I’ll prioritize compatibility with ESP-IDF v5.4 and include alternatives for earlier versions if necessary.I’ll also look for CMake-based configurations that support UDP streaming, mDNS, and WiFi provisioning, as well as full SDK configs, CMakeLists, and pin setups relevant to the Waveshare ESP32-P4-NANO board.I’ll get back to you shortly with working examples, version compatibility guidance, and integration insights.Working Examples of ESP32-P4 + ESP32-C6 WiFi Co-ProcessorESP-Hosted Quick Demo (ESP32-P4 with ESP32-C6): Espressif’s official ESP-Hosted MCU solution demonstrates a working P4+C6 setup. For example, the standard Wi-Fi iperf application can run on an ESP32-P4 host by using an ESP32-C6 (via SDIO) to provide Wi-Fi. In this demo, the P4 runs unmodified ESP-IDF networking code (e.g. esp_wifi API calls and sockets) while the C6 serves as a WiFi 6 radio. Espressif’s documentation notes that the ESP32-P4-Function-EV-Board (which has an on-board ESP32-C6) can run the stock ESP-IDF iperf example over Wi-Fi by including the esp_wifi_remote/esp_hosted components. This confirms that UDP streaming, mDNS (via esp_netif), and Wi-Fi provisioning (e.g. SmartConfig or SoftAP provisioning) all work normally on the P4 – the Wi-Fi calls are simply remoted to the C6 transparently. Another example is the Waveshare P4 demo: a simple Wi-Fi station app on ESP32-P4 (target esp32p4) was shown connecting to an AP through an ESP32-C6 by adding the espressif/esp_wifi_remote and espressif/esp_hosted components to the project. In summary, any existing ESP-IDF Wi-Fi example (Wi-Fi scan, station, MQTT, etc.) can be adapted to P4 + C6 by adding those components and configuring the project for the remote WiFi interface. Espressif provides a ready-made “host” example in the esp-hosted-mcu repo, and a matching “slave” firmware for the C6 (see esp_hosted:slave example). These can serve as templates for your own project.esp_wifi_remote & ESP-IDF Version CompatibilityIt’s critical to use matching versions of esp_wifi_remote and ESP-IDF, because esp_wifi_remote generates its Wi-Fi stubs based on a specific ESP-IDF WiFi API version. Mismatched versions cause compilation errors like the one you encountered (unknown type name 'wifi_tx_rate_config_t'). In your case, esp_wifi_remote v0.5.x was not aligned with ESP-IDF v5.4, so it referenced a Wi-Fi API type that didn’t exist in IDF 5.4. (The type wifi_tx_rate_config_t was introduced in a later IDF update for configuring 802.11 TX rates, and older esp_wifi_remote versions expected it.) To fix this, you have a few options:? Use Updated Components for IDF 5.4+: Bump to a newer release of esp_wifi_remote that explicitly supports IDF 5.4. Espressif resolved the API changes in version v0.11.2 and above (for example, v0.11.2 notes “Update per v5.4” changes). The latest versions (v0.14.x as of mid-2025) include compatibility updates for IDF 5.3, 5.4, and 5.5. Using the latest esp_wifi_remote (and its dependency esp_hosted) with ESP-IDF 5.4 should eliminate the wifi_tx_rate_config_t error, since the component will either include the proper definition or omit that call based on IDF version. In practice, you can run:idf.py add-dependency "espressif/esp_wifi_remote^0.11.2" (or higher) to pull a version compatible with 5.4.? Match IDF to the Component: Alternatively, use the ESP-IDF version that the older esp_wifi_remote v0.5.x was designed for. The 0.5.x series of esp_wifi_remote came out before IDF 5.4. In community demos, IDF v5.3.1 with esp_wifi_remote ~v0.4–0.5 was known to work. If downgrading is feasible, using IDF 5.3 with esp_wifi_remote 0.5.5 (for example) would avoid the type mismatch (since IDF 5.3 didn’t yet include the new TX rate API). Essentially, v0.5.x aligns with IDF 5.0–5.2 era, and newer esp_wifi_remote releases track later IDF releases. If you cannot move to a newer component, sticking with IDF 5.3 is a workaround.? Patches (Not Ideal): As a last resort, one could patch the component by stubbing or removing the offending reference. For instance, commenting out the use of wifi_tx_rate_config_t in the generated esp_wifi_remote.h might allow the build to succeed. However, this is not recommended – it’s better to use the correct version combo. The esp_wifi_remote changelog shows that the maintainers continuously update the component to mirror IDF’s Wi-Fi headers, so leveraging those official updates is the safest path. In short, choose version combinations that Espressif’s CI has validated: e.g. IDF 5.4 with esp_wifi_remote ≥0.11.2, or IDF 5.3 with esp_wifi_remote 0.5.x.Configuration: sdkconfig and Build SetupWhen integrating esp_wifi_remote/esp_hosted, you must ensure the project doesn’t attempt to use a native Wi-Fi driver. On ESP32-P4, this is naturally handled – the P4 has no internal WiFi, and its SOC capabilities reflect that (SOC_WIFI_SUPPORTED=n by default). For targets with WiFi (e.g. if one tried to use a C3 or S3 as host), Espressif’s docs instruct disabling all SOC_WIFI_* KConfig options to n to prevent linking the native Wi-Fi driver. In your case (ESP32-P4), no extra step is needed in sdkconfig – the P4’s ESP-IDF build knows Wi-Fi is absent. Just verify that in menuconfig under Component config ? Wi-Fi, the WiFi feature is off or unavailable (it should be).Including the Components: Add the esp_wifi_remote and esp_hosted components to your project either via the component manager or as Git submodules. The simplest method is the one you already used: idf.py add-dependency "espressif/esp_wifi_remote" (and similarly for esp_hosted). This generates an idf_component.yml listing those deps. For example, after adding them, your project manifest will include entries like espressif/esp_hosted: "*" and espressif/esp_wifi_remote: "*". At CMake configure time, these components inject the correct stub libraries and Kconfig options. In particular, esp_wifi_remote provides do-nothing (weak) implementations of all esp_wifi_xxx functions, which esp_hosted then overrides with RPC-enabled versions. This ensures your calls to esp_wifi_init(), esp_wifi_start(), etc. are bound to the remote WiFi RPC layer and not to any missing driver. (If you see duplicate symbol errors, it means the native esp_wifi might still be linking – double-check that esp_wifi isn’t in your CMake REQUIRES and that SOC_WIFI_SUPPORTED is off.) In summary, list esp_wifi_remote in your component requirements instead of esp_wifi. The component manager will pull the correct dependencies: esp_wifi_remote in turn depends on esp_hosted and protobuf-c.KConfig Menu Settings: After adding the components, run idf.py menuconfig. You’ll find a new menu under Component config ? ESP-Hosted config (on the host side). Here you configure the transport and pins: select SDIO 4-bit mode (or 1-bit mode) depending on your wiring, set the host SPI/SDIO bus (for P4 it should default to the HS2 SDIO interface), and assign the GPIO numbers for the slave reset line and any handshake lines if used. On the slave side (ESP32-C6), when you build the esp_hosted:slave example, you’ll get an “Example Configuration” menu where you can set the SDIO mode and pins for the C6. The good news is that the ESP32-P4-Function-EV-Board definitions are built-in – the default configurations in ESP-Hosted are meant to match the P4 EV board hardware. For instance, by default it knows the P4 is using SDIO with the C6. If you use the same pins as the EV board, you may not need to change much in menuconfig at all.SDIO Pin Mapping: Ensure the physical wiring (or board schematic) matches the config. The Waveshare P4 Nano and Espressif P4 EV board connect the P4’s HS2 SDIO interface to the C6’s SDIO slave interface. On the ESP32-C6, the dedicated SDIO slave pins are: CLK = GPIO19, CMD = GPIO18, DAT0 = GPIO20, DAT1 = GPIO21, DAT2 = GPIO22, DAT3 = GPIO23. The ESP32-P4 side uses its HS2 (SDIO host) pins for these signals (e.g. P4 GPIO36->C6 GPIO19 for CLK, P4 GPIO37->C6 GPIO18 for CMD, P4 GPIO35/34/33/48 -> C6 GPIO20/21/22/23 for data lines, respectively). These should already be correct if you’re using the Function EV board (the default SDIO routing). In menuconfig, you can double-check under ESP-Hosted config that the SDIO bus width is set to 4-bit. (Tip: for initial testing, you can set it to 1-bit mode which only uses CMD, DAT0 and is more forgiving of signal integrity issues on the other lines.) Also configure the SDIO clock frequency if that option is exposed – by default it might use 40 MHz; using a lower freq (e.g. 10–20 MHz) can help if you encounter stability problems during bring-up.SDIO Initialization and Integration DetailsSlave Firmware: The ESP32-C6 must be running the appropriate firmware to respond to the P4’s requests. Espressif provides a ready-made slave project for this. After installing the components, you can create it with idf.py create-project-from-example "espressif/esp_hosted:slave". Set the target to esp32c6 and build/flash this onto the C6. This firmware sets up the C6 as a Wi-Fi/BLE co-processor listening for RPC commands over SDIO. It essentially runs an idle loop waiting for the host’s requests (and handles Wi-Fi events, etc., on behalf of the host).Host Initialization Sequence: On power-up, your ESP32-P4 application will initialize the SDIO transport and attempt to bring up the Wi-Fi interface via the remote. The ESP-Hosted host code usually performs a hardware reset of the slave at start. For example, on the EV board, P4 GPIO54 is wired to the C6’s EN pin; the logs show “Reset slave using GPIO[54]” during init. Make sure your sdkconfig specifies the correct reset GPIO (the default for the EV kit is 54). After resetting the C6, the host driver will wait for a handshake from the slave (SDIO ready/INT signals). This is all handled inside the esp_hosted transport driver – you’ll see log messages like “Received INIT event from ESP32 peripheral” when the link comes up. Once that is done, from the application perspective you can call the normal esp_wifi_* APIs on the P4. For example, calling esp_wifi_start() will internally RPC to the C6 to start its Wi-Fi, and events like WIFI_EVENT_STA_CONNECTED come back to the P4 over RPC and are posted to your event loop as usual. In short, after the initial setup, using Wi-Fi on the P4 feels just like using an integrated Wi-Fi chip. You can use ESP-IDF’s mdns component, ESP-NETIF networking, UDP sockets, and even things like esp_wifi_set_ps() or provisioning managers – all those calls are forwarded to the C6 seamlessly. The throughput over SDIO is also quite good (4-bit SDIO can achieve several Mbps; Espressif chose SDIO to support high data rate use cases like camera streaming).Troubleshooting Tips: If the build succeeds but you get runtime errors, check that both sides run matching versions of esp-hosted. Espressif recommends using the same esp-hosted release on host and slave to avoid protocol mismatches. Also verify the C6’s firmware printouts – on boot it should indicate “ESP-Hosted-MCU Slave” and list supported features (WLAN over SDIO, etc.). If the P4 is not communicating, ensure the C6 is reset (if your custom board didn’t route a reset line, you may need to reset the C6 manually or via EN pulldown). For SDIO, both host and slave must use the same bus mode (1-bit vs 4-bit) and clock. If you see garbage or failures, try 1-bit mode and a lower clock as mentioned. Finally, confirm your sdkconfig for the P4 hasn’t accidentally enabled other conflicting features (e.g. some menu options like Wi-Fi NAN or Wi-Fi mesh – these should be off or compatible with wifi_remote). The esp_wifi_remote component’s menuconfig will have a “Slave target” option (it defaults to ESP32-C6 for P4 targets) – ensure it is set to C6 since that’s your WiFi chip.Version Options SummaryGiven your requirements, here are viable version combos:? ESP-IDF v5.4 option: Use the latest ESP-Hosted components. For example, ESP-IDF 5.4 + esp_wifi_remote v0.14.x + esp_hosted v2.0.x (the esp_hosted component was around v2.0.16 latest). This should compile without errors and supports Wi-Fi 6 features. It will include the wifi_tx_rate_config_t API on both sides, so no unknown types. (Make sure to update your ESP-IDF to the 5.4 release or latest 5.4 branch, as some fixes for P4 might only be in the final release, not in early previews.)? ESP-IDF v5.3 option: If issues persist with 5.4, you can fall back to IDF 5.3. Espressif’s P4 documentation and kit examples were originally tested on v5.3.1. Using IDF 5.3.2 with esp_wifi_remote v0.5.5 (or even v0.4.1) is known to work (the Waveshare demo used IDF 5.3 and the * latest components at that time). You may lose some newest Wi-Fi 6 APIs, but standard Wi-Fi functionality (STA/AP, WPA3, mDNS, etc.) is supported.? Future IDF versions: Looking ahead, IDF v5.5 (or v6.0) will also be supported by new releases of esp_wifi_remote. In fact, esp_wifi_remote v0.14.3 mentions updates for “v5.5 changes” and even some v6.0 adjustments. So if you plan to upgrade to IDF 5.5, be sure to also update to the corresponding esp_wifi_remote (likely v0.15+ when available). The Espressif component registry and changelogs can guide you on which version to use for a given IDF.In conclusion, to solve the build error use an IDF–component pairing that aligns (for IDF 5.4, that means upgrading your esp_wifi_remote/esp_hosted components). Once compiled, follow the configuration and flashing steps: flash the C6 with slave firmware, flash the P4 with your app, and you should be able to do Wi-Fi provisioning, advertise via mDNS, and stream UDP from the P4 through the C6 co-processor. This dual-chip WiFi setup is intended to be seamless, and many have already achieved it on the P4 EV kits with the guidelines above.Sources:? Espressif ESP-Hosted MCU documentation (esp_hosted component README)? esp_wifi_remote component README and changelog? Waveshare ESP32-P4 WiFi Station Example (using esp_hosted + esp_wifi_remote)? Espressif forum/notes on SDIO pin assignments and usage on C6? ESP-IDF 5.5 Wi-Fi API docs (esp_wifi_config_80211_tx and wifi_tx_rate_config_t) (for context on API changes)? ESP-Hosted config guidance (Espressif dev-kits documentation)
Claude
ESP32-P4 + ESP32-C6 WiFi Integration SolutionsImmediate Fix for Your Build ErrorThe wifi_tx_rate_config_t error you're encountering is caused by version incompatibility between esp_wifi_remote v0.5.x and ESP-IDF v5.4. Here's the solution:Primary Solution: Upgrade esp_wifi_remote# Remove old version and add compatible versionidf.py add-dependency "espressif/esp_wifi_remote^0.12.1"Why this works: esp_wifi_remote v0.12.1 specifically adds "Support for IDF v5.4 via a separate dir" according to the component changelog. The v0.5.x series was built for earlier ESP-IDF versions and lacks the type definitions needed for v5.4.Alternative: Use ESP-IDF v5.3If you must use esp_wifi_remote v0.5.x:# Install ESP-IDF v5.3.xgit clone -b v5.3 --recursive https://github.com/espressif/esp-idf.gitWorking GitHub Examples1. Official Espressif ImplementationRepository: espressif/esp-hosted-mcu? Contains ESP32-P4-Function-EV-Board example with on-board ESP32-C6? Pre-configured for SDIO 4-bit transport (79.5 Mbps UDP throughput)? Documentation: /docs/esp32_p4_function_ev_board.md? Supports ESP-IDF v5.3+2. Waveshare ESP32-P4-NANO SupportRepository: waveshareteam/Waveshare-ESP32-components? Confirmed support for your exact board? Includes WiFi integration examples? Uses SDIO interface protocolComplete Configuration GuideStep 1: Project Dependencies# Create project and set targetidf.py create-project esp32_p4_wifi_projectcd esp32_p4_wifi_projectidf.py set-target esp32p4# Add working component versionsidf.py add-dependency "espressif/esp_wifi_remote^0.12.1"idf.py add-dependency "espressif/esp_hosted^0.0.14"Step 2: Critical sdkconfig SettingsCreate sdkconfig.defaults with these essential configurations:# Disable native WiFi on ESP32-P4CONFIG_ESP_WIFI_ENABLED=nCONFIG_SOC_WIFI_SUPPORTED=n# Enable WiFi RemoteCONFIG_ESP_WIFI_REMOTE_ENABLED=y# Slave target configurationCONFIG_SLAVE_IDF_TARGET="esp32c6"CONFIG_SLAVE_SOC_WIFI_SUPPORTED=y# WiFi buffer settings for performanceCONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM=16CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM=64CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM=64CONFIG_ESP_WIFI_AMPDU_TX_ENABLED=yCONFIG_ESP_WIFI_TX_BA_WIN=32CONFIG_ESP_WIFI_AMPDU_RX_ENABLED=yCONFIG_ESP_WIFI_RX_BA_WIN=32Step 3: CMakeLists.txt ConfigurationMain project CMakeLists.txt:cmake_minimum_required(VERSION 3.16)include($ENV{IDF_PATH}/tools/cmake/project.cmake)project(esp32_p4_wifi_remote)Component CMakeLists.txt (in main/):idf_component_register(    SRCS "main.c"    INCLUDE_DIRS "."    REQUIRES         esp_wifi_remote        esp_hosted        esp_netif        esp_event        nvs_flash)# Prevent symbol conflictstarget_compile_definitions(${COMPONENT_LIB} PRIVATE    -DESP_WIFI_REMOTE_ENABLED=1)SDIO Pin ConfigurationYour SDIO pin configuration is valid for ESP32-P4:ESP32-P4 Host (Your Configuration)sdmmc_slot_config_t slot = SDMMC_SLOT_CONFIG_DEFAULT();slot.clk = GPIO_NUM_36;  // Your CLK pinslot.cmd = GPIO_NUM_37;  // Your CMD pin  slot.d0 = GPIO_NUM_35;   // Your D0 pinslot.d1 = GPIO_NUM_34;   // Your D1 pinslot.d2 = GPIO_NUM_33;   // Your D2 pinslot.d3 = GPIO_NUM_48;   // Your D3 pinslot.width = 4;          // 4-bit modeESP32-C6 Slave (Fixed Pins)? CLK: GPIO19, CMD: GPIO18? D0: GPIO20, D1: GPIO21, D2: GPIO22, D3: GPIO23Hardware Requirements1. Pull-up resistors: 10kΩ-51kΩ on CMD and all data lines2. Voltage: 3.3V for all SDIO signals3. Connections: Keep traces/wires under 5cm for reliability4. Reset line: Add a GPIO connection for slave reset controlWorking Implementation CodeComplete Host Initialization (ESP32-P4)#include "esp_wifi_remote.h"#include "esp_hosted.h"#include "driver/sdmmc_host.h"#include "esp_log.h"void app_main(void) {    // Initialize NVS    esp_err_t ret = nvs_flash_init();    if (ret == ESP_ERR_NVS_NO_FREE_PAGES ||         ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {        ESP_ERROR_CHECK(nvs_flash_erase());        ret = nvs_flash_init();    }    ESP_ERROR_CHECK(ret);    // Initialize network stack    ESP_ERROR_CHECK(esp_netif_init());    ESP_ERROR_CHECK(esp_event_loop_create_default());    // SDIO host configuration    sdmmc_host_t host = SDMMC_HOST_DEFAULT();    host.max_freq_khz = 40000; // 40 MHz for best performance    // Configure your SDIO pins    sdmmc_slot_config_t slot_config = SDMMC_SLOT_CONFIG_DEFAULT();    slot_config.clk = GPIO_NUM_36;    slot_config.cmd = GPIO_NUM_37;    slot_config.d0 = GPIO_NUM_35;    slot_config.d1 = GPIO_NUM_34;    slot_config.d2 = GPIO_NUM_33;    slot_config.d3 = GPIO_NUM_48;    slot_config.width = 4;    // Initialize SDIO    ESP_ERROR_CHECK(sdmmc_host_init());    ESP_ERROR_CHECK(sdmmc_host_init_slot(SDMMC_HOST_SLOT_1, &slot_config));    // Initialize WiFi remote    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_remote_init(&cfg));        // Configure WiFi    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_start());        // Your WiFi provisioning, mDNS, and UDP streaming code here}Troubleshooting Common Issues1. Symbol ConflictsIf you encounter "multiple definition" errors:# Add to CMakeLists.txttarget_compile_options(${COMPONENT_LIB} PRIVATE    -Wno-unused-function    -Wno-unused-variable)2. SDIO Timeout Errors? Verify all pull-up resistors are installed? Check voltage levels (must be 3.3V)? Reduce wire length to under 5cm? Ensure proper ground connection between boards3. Build System IssuesForce clean rebuild:idf.py fullcleanrm -rf sdkconfigidf.py menuconfig  # Reconfigureidf.py buildVersion Compatibility MatrixESP-IDFesp_wifi_remoteesp_hostedStatusv5.4.xv0.12.1+v0.0.14? Workingv5.3.xv0.5.3v0.0.14? Workingv5.4.xv0.5.xAny? Type errorsNext Steps1. Immediate: Upgrade to esp_wifi_remote v0.12.1 to fix your build error2. Hardware: Verify SDIO connections and add pull-up resistors3. Testing: Use the provided initialization code as a starting point4. Performance: Once working, optimize with the buffer settings providedThe ESP32-P4 + ESP32-C6 combination is well-supported by Espressif with active development. Your Waveshare ESP32-P4-NANO board configuration is valid and should work with the solutions provided above.